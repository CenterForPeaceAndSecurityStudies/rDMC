---
title: "04 Dependent Variable - Specialization"
author: "J Andres Gannon"
date: "November 21, 2019"
output:
  html_document:
    toc: yes
  html_notebook:
    toc: yes
    toc_float: yes
editor_options:
  chunk_output_type: inline
---
<style>
    body .main-container {
        max-width: 100%;
    }
</style>

# Prep
Pipe operators have trouble loading in-line so we load those first.
```{r}
library(magrittr)
library(ggplot2)
```

# Load and clean data
We start by loading the cleaned IISS data. This dataframe contains information about the count of military units at the country-year level. This version of the data only contains the year 2014 since the other years are still being cleaned and processed.

```{r}
# Load data
df <- readRDS(file = paste0(here::here(), '/data/IISS_clean_November_25_2019.rds'))
head(df)

# Drop descripter columns
vars_drop <- c('service', 'subservice', 'subsubservice', "rawtext", "new_row", "old_row")

df <- dplyr::select(df, -vars_drop)

# Summary stats
df$unit_count <- as.numeric(df$unit_count)
unit_count <- nrow(df)

unittype_count <- length(summary(as.factor(df$unit_name),maxsum=50000))
tek_count <- length(summary(as.factor(df$equipment_name),maxsum=50000))
```

There are `r unit_count` types of military units in the data, aggregating across countries. These represent `r unittype_count` unique types of military units that are nested inot `r tek_count` categories of military technologies.

# Reshape data
We want the dataframe to have each row as a technology and each column as a country. Each cell then represents a count of that military technology owned by a given country in a given year.
```{r}
# Collapse to the tek level
df_long <- df %>%
  dplyr::group_by(country, equipment_type) %>%
  dplyr::summarise(frequency = sum(unit_count))

df_wide <- df_long %>%
  tidyr::spread(equipment_type, frequency)

# Set na to 0
df_wide[is.na(df_wide)] <- 0

df_wide <- as.data.frame(df_wide)

df_wide

# Flip back to long
df_long <- df_wide %>%
  tidyr::gather(tek, frequency, -country)

df_long
```

# Quick summary stat checks
Check count distribution
```{r}
sort(unique(df_long$frequency))

ggplot(df_long, aes(x = frequency)) + 
  geom_histogram(binwidth = 100)
```

We see from this the data is zero-inflated. Most country-teks for 2014 do not exist. Most states possess only a subset of possible teks. A binary model may produce different results
```{r}
df_binary <- df_long

df_binary[df_binary > 0] <- 1

sort(unique(df_binary$frequency))

ggplot(df_binary, aes(x = frequency)) + 
  geom_histogram(bins = 2)
```

# Specialization indexes
There are many different ways to measure specialization from economic and biology models.

I look into specialization indexes composed by the following packages:
betapart
bipartite
diverse
diveRsity
EntropyExplorer
RInSp

## Bipartite package
We essentially want to do a statistical test for the difference between observed and random networks

### Prep data
We transform the data slightly, using the wide version of the data, by converting the tek names to row names thus making the dataframe a matrix
```{r}
rownames(df_wide) <- df_wide$country
df_wide <- df_wide[ , -1]
```

Drop columns that are ordnances, not platforms, since they have no count value
```{r}
df_wide <- df_wide[, colSums(df_wide) != 0]
```

Off the shelf visualizations just show that we have a lot of data. The US has the most pieces of equipment. The most common type of equipment is armoured fighting vehicles.
```{r}
bipartite::plotweb(df_wide)
bipartite::visweb(df_wide)
```

We can then calculate a country-level measure of specialization using the d' index. This measures a country's deviation from a null model where tek portfolios were randomly determined, occurring in proportion to the available countries and technologies.
```{r}
scores <- bipartite::specieslevel(df_wide, level = "lower", index = "d")

scores <- as.data.frame(scores)

# Show state distribution graphically
scores$name <- rownames(scores)

p1 <- ggplot2::ggplot(scores, aes(x = reorder(name, d) , y = d)) + 
  geom_point(col = "red", alpha = .3) + 
  coord_flip() + 
  theme(axis.title.y = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank(), text = element_text(size = 14)) + 
  labs(title = "Military Specialization Scores (2014)", x = "Country (Rank Order)", y = "d' Score") +
  theme_light()
p1

ggsave("../paper/figures/specialization_scores/2014_equipment-type.png", height = 12, units = "in")

# Show simple histogram
hist(scores$d)
```

Low scores indicate diversification and high scores indicate specialization.

## Prep scores df
```{r}
scores$state <- countrycode::countrycode(scores$name, "country.name", "cown")

# For now, drop states without a COW code
scores <- scores[!is.na(scores$state), ]
```

We compare this measure to a null model that is a random network constructed from proportionally possible interactions given the number of states. We apply the Patefield algorithm by getting a division of labor score for an alliance network and comparing it to the division of labor scores from simulations of random networks that represent null alliances. We then observe the distribution of the null-model values compared to the specialization index we observe.
```{r}
Iobs <- vegan::nestednodf(df_wide)$statistic[3]
nulls <- bipartite::nullmodel(web = df_wide, N = 1000, method = 'r2d')
Inulls <- sapply(nulls, function(x) vegan::nestednodf(x)$statistic[3])
plot(density(Inulls), xlim = c(0, 100), lwd = 2, main = "NODF")
abline(v = Iobs, col = "red", lwd = 2)
png('../paper/figures/specialization_scores/nodf.png')
```




We then do a more complex model that looks at z-scores instead of the difference between observed and simulated values.
```{r}
# Convert to moduleWeb-class object
mod <- bipartite::computeModules(df_wide)

# Get cz values from the data
bipartite::czvalues(mod)
```

Test some other things that could be helpful. The following might be the most important function since it calculates the deviation from a null model that assumes tek acquisition happens randomly in proportion to the available countries and teks.

From the function description:
The d' index is derived from Kulback-Leibler distance (as is Shannon's diversity index), and calculates how strongly a species deviates from a random sampling of interacting partners available. It ranges from 0 (no specialisation) to 1 (perfect specialist). In the case of a pollination web, a pollinator may be occurring only on one plant species, but if this species is the most dominant one, there is limited evidence for specialisation. Hence this pollinator would receive a low value. In contrast, a pollinator that occurs only on the two rarest plants would have a very high value of d'.

The idea of this index is laid out in Blüthgen et al. (2006). It basically calculates the Shannon-diversity for each column (delivering the raw d-values) and re-ranges them between the theoretical maximum and minimum (yielding values between 0 and 1). dmax is given analytically (see paper or code), but dmin must be found ‘heuristically’, since the web can only contain integers. The idea behind the heuristic minimum is that d will be minimal when observed values differ least from expected values based on marginal distributions.

The way this function is implemented, it calculates expected values for each cell based on the product of observed marginal sums (i.e. column and row sums) times sum(web). Then it rounds off to integers and allocates the remaining interactions in two steps: First, all columns and rows with marginal sums of 0 obtain one interaction into the cell with the highest expected value. Secondly, all remaining interactions are distributed according to difference between present and expected value: those cells with highest discrepancy receive an interaction until the sum of all entries in the new web equals those in the original web. Now the d-values for this web are calculated and used as dmin.

Simple rounding of expected values would lead to empty columns or rows, i.e. the dmin-web would be of lower dimension than the original web.


dfun returns the d' values for the lower trophic level. Use fun(t(web)) to get the d'-values for the higher trophic level (as does specieslevel). If you want to provide external abundances, you must provide those of the OTHER trophic level! (This help file is written as if you were interested in the lower trophic level.)

d' is one of several species-level network indices. It's generalisation to the entire interaction web is called H2'.

The abundances vector allows to incorporate independent estimates of the abundances of the HIGHER trophic level. In a pollination web, pollinator abundances may be very different from those estimated by the interaction matrix column sums. This has also, obviously, large consequences for the specialisation: A plant being pollinated by a bee that is common on this plant, but very rare in general, will show a low specialisation unless bee abundances are corrected for. Data given in the abundance vector are here used in replacement for the row sums, both in the d-function itself, as well as in the calculation of the minimum ds.

In contrast to H2fun, finding the minimum value of d violates marginal totals. The idea is that we look at each species in turn. Then, we estimate how its observed number of interactions can be distributed, given the marginal totals (i.e. if 5 interactions were observed, they cannot be put into a link that only has 3 interactions across all species). So, for each species the number of interactions never exceeds the total across all species, but if we would put the web together from this sequential scan, it may well do so. In our view, this is irrelevant, because we are interested in the potential of each species separately to be perfectly specialised (given the marginal totals), not for the entire web. We leave this to H2fun.
```{r}
df_dval <- bipartite::dfun(df_wide)
```

This tells all the specialization index values
```{r}
# bipartite::grouplevel(df_wide)
```

# Merge other covariates
Now that we have a score for each country, we can merge other covariates of interest to test specialization
## Alliance data
We take the alliance data from ATOP 4.0 at the country-year level
```{r}
# Read in data
atop <- read.csv(file = paste0(here::here(), '/inst/extdata/ATOP/atop4_0sy.csv'))
head(atop)

# Subset to 2014
atop <- subset(atop, year == "2014")

# Select vars
vars_keep <- c('state', 'year', 'atopally', 'number')

atop <- dplyr::select(atop, vars_keep)

# Merge based on cow code values
scores <- dplyr::left_join(scores, atop, by = "state")
```

# Archive
## Diverse package
```{r}
round(diverse::diversity(df_long, type = c('hhi', 'gs', 'b','ev')), 3)

colfunc <- colorRampPalette(c("deepskyblue4", "deepskyblue", "cyan"))
plot_mat <- function(df_long)
pheatmap::pheatmap(df_long, colfunc(100), cluster_rows = FALSE, cluster_cols = FALSE)

col_l <- names(sort(colSums(diverse::values(df_long)))) #order
row_l <- names(sort(rowSums(diverse::values(df_long)), decreasing = TRUE))

par(mfrow = c(2,2))

plot_mat(diverse::values(df_long)[row_l,col_l])
plot_mat(diverse::values(df_long, norm = 'p')[row_l,col_l])
plot_mat(diverse::values(df_long, norm = 'rca')[row_l,col_l])
plot_mat(diverse::values(df_long, norm = 'rca', filter = 1)[row_l,col_l])
```

Fix code breaks below
plot_mat(diverse::values(df_binary)[row_l,col_l])
plot_mat(diverse::values(df_binary, norm = 'p')[row_l,col_l])
plot_mat(diverse::values(df_binary, norm = 'rca')[row_l,col_l])
plot_mat(diverse::values(df_binary, norm = 'rca', filter = 1)[row_l,col_l])


```{r}

```
