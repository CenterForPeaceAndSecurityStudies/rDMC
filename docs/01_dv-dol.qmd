---
title: '01 Dependent Variable - Division of Labor'
author:
  - name: J Andrés Gannon
    email: "andres.gannon@gmail.com"
    url: jandresgannon.com
    affiliation: Council on Foreign Relations
format:
  pdf:
    fig-format: png
    thanks: test text here
editor: visual
execute:
  echo: false
  warning: false
  cache: true
date: "`r format(Sys.Date(), '%B %d, %Y')`"
header-includes:
- \usepackage{tikz}
- \usepackage{pgfplots}
- \pgfplotsset{compat=newest}
- \usetikzlibrary{plotmarks}
- \usetikzlibrary{arrows.meta}
- \usepgfplotslibrary{patchplots}
- \usepackage{grffile}
- \usepackage{caption}
- \usepackage[utf8]{inputenc}
- \usepackage[doublespacing]{setspace}
- \AtBeginEnvironment{tabular}{\singlespacing}
- \usepackage{float}
- \usepackage{multirow}
- \usepackage{tablefootnote}
- \usepackage{pifont}
- \usepackage{newunicodechar}
- \usepackage{booktabs}
- \usepackage{tabularx}
- \newunicodechar{✓}{\ding{51}}
bibliography: ForceStructure.bib
---

```{r knitr_options, echo = FALSE, warning = FALSE, cache = FALSE}
library(knitr)
library(kableExtra)
library(magrittr)
library(ggplot2)
```

# Load data
## rDMC

```{r load data}
rdmc_long <- readRDS(file = paste0(here::here(), '/data/rDMC_long_v1.rds'))

rdmc_wide <- readRDS(file = paste0(here::here(), '/data/rDMC_wide_v1.rds'))

# Keep a separate df of just the ID vars since ccode and cname were added later and are not included in the function
id_vars <- rdmc_wide %>%
  dplyr::select(year, stateabb, country, ccode)

# Create vector of countries and years
df_year <- unique(rdmc_wide$year)
df_country <- unique(rdmc_wide$country)
```

## Alliances

We want to get columns for each alliance that are dummy variables indicating whether that country was in that alliance

```{r}
# Load
atop_member <- rio::import(paste0(here::here(), "/inst/extdata/ATOP/atop5_1m.csv")) %>%
  dplyr::filter(yrexit > 1970 |
                  yrexit == 0) %>%
  dplyr::mutate(yrexit = dplyr::if_else(yrexit == 0,
                                        2023,
                                        yrexit)) %>%
  dplyr::filter(defense == 1) %>%
  dplyr::select(atopid, member, yrent, yrexit) %>%
  dplyr::distinct() %>%
  dplyr::mutate(row = dplyr::row_number()) %>%
  dplyr::group_by(row, atopid, member) %>%
  dplyr::reframe(year = seq(yrent, yrexit)) %>%
  dplyr::ungroup() %>%
  dplyr::select(-row) %>%
  dplyr::rename(ccode = 'member')

# Merge the alliance-year-member df with the wide version of the data and then create a column for alliance-year since that's what we're filter by when making the DoL index
df <- dplyr::left_join(rdmc_wide, atop_member) %>%
  dplyr::mutate(atopid = dplyr::if_else(is.na(atopid),
                                              0, atopid)) %>%
  tidyr::unite(col = "alliance_year",
               atopid, year,
               remove = FALSE) %>%
  dplyr::select(-atopid)
```

# Testing grounds

## Alliance DoL
We're going to test the alliance-level DoL variables, using a single alliance-year as a sample

Higher H2 values means more complementary specialization within the alliance network

```{r}
# initial empty list
my_list <- list()
  
# define function
func <- function(df_allianceyear){
  
  test <- df %>% 
    dplyr::filter(alliance_year == df_allianceyear) %>%
    tidyr::unite(col = "rowname", alliance_year, ccode, remove = TRUE) %>%
    tibble::column_to_rownames(var = "rowname") %>%
    dplyr::select(-c(year, country, stateabb)) %>%
    replace(is.na(.), 0) %>%
    janitor::adorn_percentages(denominator = "col",
                               na.rm = TRUE) %>%
    janitor::untabyl() %>%
    replace(is.na(.), 0)

  scores <- bipartite::networklevel(test,
                                    index = "quantitative",
                                    level = "lower") %>%
    as.data.frame() %>%
    dplyr::rename('scores' = '.')
  
  # save each alliance-year as a dataframe in a list
  my_list[paste(df_allianceyear)] <<- list(scores)
}

# loop through all alliance-years
df_allianceyear <- unique(df$alliance_year)

for(i in df_allianceyear){
  func(df_allianceyear = i)
}

### AG pick up here after soccer!
# bind nested datasets into a complete dataframe
d_by_allianceyear <- do.call(rbind.data.frame, my_list)

# Rename as the method used
h2 <- as.data.frame(d_by_allyyear) %>%
  tibble::rownames_to_column(var = "id") %>%
  tidyr::separate(id, into = c("atopid", "year"), sep = "_") %>%
  dplyr::mutate(atopid = gsub("[^0-9.-]", "", atopid)) %>%
  dplyr::mutate(year = as.numeric(year))

saveRDS(h2, paste0(here::here(), "/data/","DV_dol-alliance.rds"))
```

```{r}
# NATO 2004
sample <- df %>%
  dplyr::filter(alliance_year == "3180_2004") %>%
  dplyr::select(-alliance_year, -year) %>%
  replace(is.na(.), 0) %>%
  janitor::adorn_percentages(denominator = "col",
                               na.rm = TRUE) %>%
  janitor::untabyl() %>%
  replace(is.na(.), 0) %>%
  tibble::column_to_rownames(var = "stateabb") %>%
  dplyr::select(-country, -ccode)

sample_raw <- df %>%
  dplyr::filter(alliance_year == "3180_2004") %>%
  tibble::column_to_rownames(var = "stateabb") %>%
  dplyr::select(-country, -ccode, -alliance_year, -year) %>%
  replace(is.na(.), 0) %>%
  dplyr::select_if(colSums(.) != 0)

# Get measures
bipartite::networklevel(sample,
                        index = "quantitative",
                        level = "lower") %>%
  as.data.frame() %>%
  dplyr::rename('scores' = '.')
```

## Visuals

```{r}
# Viz as matrix
sample %>%
  bipartite::visweb(type = "diagonal",
                    labsize = 3)

# Viz as sankey
sample %>%
  bipartite::plotweb(labsize = 2,
                     col.interaction = "red",
                     bor.col.interaction = "gray50",
                     y.lim = c(-0.1, 3),
                     text.rot = 90)

## Compare once we have the full df coded
h2 %>%
  dplyr::mutate(atopid = dplyr::recode(atopid, 
                                       "3075" = "Rio Treaty",
                                       "3150" = "OAS",
                                       "3180" = "NATO",
                                       "3210" = "US-Philippines",
                                       "3215" = "ANZUS",
                                       "3240" = "US-ROK",
                                       "3260" = "US-Thailand",
                                       "3355" = "US-Pakistan",
                                       "3360" = "US-Turkey",
                                       "3375" = "US-Japan")) %>%
  ggplot(aes(x = year,
             y = h2,
             color = atopid)) +
  geom_line() +
  geom_smooth() +
  gghighlight::gghighlight(atopid %in% c("Rio Treaty",
                                         "OAS",
                                         "NATO",
                                         "ANZUS",
                                         "US-Philippines",
                                         "US-ROK",
                                         "US-Thailand",
                                         "US-Pakistan",
                                         "US-Turkey",
                                         "US-Japan"),
                           use_direct_label = TRUE) +
  theme_minimal() +
  facet_wrap(~bilat) +
  labs(title = "Division of Labor of Military Capabilities within Alliances",
       caption = "US alliances highlighted",
       x = "Year",
       y = "Division of Labor") +
  theme(legend.position = 'none')
```

## Within-alliance modularity

Modularity is a way of thinking about who has an important role in an alliance network. It's a form of specialization in that it describes countries that have similar roles, where roles are determined by the military capabilities they possess. The interaction matrices within each module are similar, indicating those countries do similar things.

A module is a group of states within an alliance that are more closely connected to each other than the countries in other modules. A way of thinking about modules is that countries in the same module are performing the same role (Guimera 2005)

***Null model is important because it's what allows you to compare alliances of different sizes. You compare the real alliance to null simulations of that same matrix and those figures can be compared with one another (Vazquez & Aizen, 2003; Bluthgen et al., 2008; Dormann et al., 2009)

C score is a standardized measure that refers to among-module role (meaning the entire alliance network). If all your teks are within your module, your C score is 0. If your teks are evenly distributed across all modules, your C score is 1
Z score is a standardized measure that refers to within module role (meaning within its module within the alliance)

Types of countries (Olesen et al 2007 from biology)
peripheral country = low C and low Z. It's a specialist who really only does one thing
connector country = high C and low Z. It glues modules together and is important for network coherence
module hub country = low C and high Z. It is important to its own module
network hub country = high C and high Z. It is important to its module and overall

```{r}
# Calculate cut off thresholds for cz scores
## Computer scores
modules <- sample_raw %>%
  bipartite::computeModules() %>%
  bipartite::czvalues(weighted = TRUE,
                      level = "lower")

## run null models to see what it would be in 1000 random simulations
nulls <- bipartite::nullmodel(sample_raw,
                              N = 1000)
null.mod.list <- sapply(nulls, bipartite::computeModules)
null.cz <- lapply(null.mod.list, bipartite::czvalues)

## computer 95% for c values across all species in nulls
null.cs <- sapply(null.cz, function(x) x$c)
## identify threshold for uncommonly high c-values
cval <- 1 - as.numeric(quantile(null.cs,
                            0.95))

## repeat the last 2 steps for z-values
null.zs <- sapply(null.cz, function(x) x$z)
zval <- as.numeric(quantile(null.zs,
                            0.95,
                            na.rm = TRUE))

# Plot with those cut offs
modules %>%
  bipartite::computeModules() %>%
  bipartite::czvalues(weighted = TRUE,
                      level = "lower") %>%
  as.data.frame() %>%
  dplyr::mutate(c = 1 - c) %>%
  tibble::rownames_to_column(var = "country") %>%
  ggplot(aes(x = c,
             y = z,
             label = country)) +
  geom_point(size = 4) +
  ggrepel::geom_text_repel(size = 10) +
  geom_vline(xintercept = cval,
             color = "red",
             size = 1) +
  geom_hline(yintercept = zval,
             color = "red",
             size = 1) +
  labs(x = "Country Specialization",
       y = "Country Uniqueness",
       caption = "Red lines indicate critical values calculated as 95% quantiles from 1,000 within-alliance simulations.") +
  theme_minimal(base_size = 30)

sample_raw %>%
  bipartite::computeModules() %>%
  bipartite::plotModuleWeb(rank = TRUE,
                           weighted = TRUE)
```

# Archive

## Normalize
```{r, eval=FALSE}
# Create object that finds the best normalization model
bn_d <- bestNormalize::bestNormalize(scores_df$d)
bn_fentrop <- bestNormalize::bestNormalize(scores_df$fentrop)
bn_sd <- bestNormalize::bestNormalize(scores_df$sd)

# Add normalized spec scores to df
scores_df$d_norm <- predict(bn_d, scores_df$d)
scores_df$fentrop_norm <- predict(bn_fentrop, scores_df$fentrop)
scores_df$sd_norm <- predict(bn_sd, scores_df$sd)
```

# Save

Save final output. A dataframe with country-year observations and specialization score indices as columns.

```{r, eval=FALSE}
scores_df <- scores_df %>%
  dplyr::select(year, country, stateabb, ccode, 
                dplyr::starts_with("spec_"))

saveRDS(scores_df, paste0(here::here(), "/data/","01_DV-specialization.rds"))
```

# Test zone
